export default class RuleController {

    constructor (rules)
    {
        this.rulesJson = rules;   
        
    }

    //ruleSelection queryTree, 
    ruleSelection = (rules, key, element, ontoType, rule, queryTree) => 
    {
        
        alert(key)
        let commands; 
        let additionalRules;
        let offerTypes;
        let uri;
        let question;
        let needElName;
        
        if (rule)
        {
            offerTypes = rule; 
        }
        else
        {
            commands = this.getSpecificRule(rules,key); 
            additionalRules = this.getAdditionalRule(commands,ontoType);
            offerTypes = (additionalRules.length > 0 ) ? offerTypes = additionalRules : offerTypes = commands.offer;   
        }

        //z elementu udělat otázku
        if (element !== false)
        {
            if (this.isElementInstace(element,queryTree))
            {
                needElName =true;
                uri = element.uri.value;
                question = this.rulesJson.questions[1].question.replace("VAL",element.label.value);
            }
            else
            {
                needElName = false;
                uri = element.uri.value;
                question = this.rulesJson.questions[0].question.replace("VAL",element.label.value);
            }
        }
        else
        {
            uri = false; 
            question = rules.questions[2].question;
        }
       

        let result = offerTypes.map(function (ruleClass) {
            return {"name": ruleClass, "uri": uri ,"origin": key};
        }.bind(this));

        return Promise.resolve({"buttons": result, "title": question, "elName": needElName, "type": "classSelection"}); 
    }

    isElementInstace = (element, queryTree) =>
    {
        for (let node of queryTree)
        {
           
            if (element.uri.value === node.uri.value  )
            {
                for (let type of node.fatherTypeRelation)
                {
                    if (this.delUri(type) === "instanceOf")
                    {
                        return true; 
                    }
                }
            
            }
        }
        return false; 
    } 

    // this.ontoController.getOntoElement(this.relation.uri.value);
    elementConsistencyRules = (element,  ontoController) => 
    {

            // v případě undefinied vyhoď, že pravidlo není definováno 
            let rules = this.rulesJson[element.ontoType]; 
           
            let check = []; 
            let checkRelation = false;
            

            //Tady by měla být pole jelikož to může být 1:N 
            // !!! Převod na metodu a úprava dle pravidel
            // udělat connect -> subtype -> supertype jenom v případě arrow 

 
            
            let subElTypes = ontoController.getRelatedTypes(element.uri,"from","Arrow");
            let superElTypes = ontoController.getRelatedTypes(element.uri,"to", "Arrow");
            let connectElTypes = ontoController.getRelatedTypes(element.uri, "connect", false);



    
            for (let rule of rules)
            {
             
                if(rule.key === "superType")
                {
                        if (!rule.type.some(r=> superElTypes.includes(r)) && rule.type.length > 0 )
                        {
                            // if includes none -> zkontrolovat lenght superType -> zeptat se jestli chci doplnit superType -> nabídnout co je v tabulce -> zkontrolovat jestli už není
                            check.push({key: "superType", types: rule.type, element:element.uri});
                        }
                }
                else if (rule.key === "subType")
                {
                       if (!rule.type.some(r=> subElTypes.includes(r)) && rule.type.length > 0)
                       {
                           check.push({key: "subType", types: rule.type, element: element.uri});
                       }
                }  
                else // connect
                {
                    if (!rule.type.some(r=> connectElTypes.includes(r)) && rule.type.length > 0)
                    {
                        check.push({key: "connect", types: rule.type, element: element.uri});
                    }
                }
            }
            
         
            return check;
    }

    
   

    getSpecificRule = (rules, key) =>
    {
        for (let node of rules)
        {
            if (node.key === key)
            {
                return node; 
            }
        }

        return false; 
    }

    getAdditionalRule = (rule, selectedType) =>
    {

        if (selectedType in rule)
        {
            return rule[selectedType];
        }
        else
        {
            return [];
        }
    }


    commonRuleSelection = (element, key, ontoModel) => 
    {
        let result = [];
      
        // tohle vyřeš na úrovni onto modelu!
        let fatherOnto = [];
        let childOnto = [];
        let connection = 0;
        if (element.connect !== null)
        {
            connection = element.connect.length + element.connectFrom.length; 
        }
   
        var fatherPuro =  this.delUri(element.fatherType);
        var childPuro =   this.delUri(element.childType);
        
        for (let node of ontoModel)
        {
            if (element.father.includes(node.uri)) {
                fatherOnto.push(node.ontoType);
            }
            
        }
        
        // Změnit!! 
        for (var rule of this.rulesJson.commonRules)
        {
            
            /*if ((fatherOnto.includes(rule.fatherOnto) || (fatherOnto.length === 0 && rule.fatherOnto === "")) &&
                (fatherPuro.includes(rule.fatherPuro) || (fatherPuro.length === 0 && rule.fatherPuro === "")) &&
                childPuro.includes(rule.childPuro) || childPuro === rule.childPuro &&
                rule.hasRelation <= connection
                )
            */
            if(true)
            {
                for(let val of rule.offer) 
                { 
                    //question atd...
                    result.push({"name":this.rulesJson.classes[val], "uri":element.uri.value, "origin": key}); 
                }
                return {"buttons": result, "title": element.label.value, type: "elementSelection"};
            }
        }
    }

    delUri = (uri) => 
    {
        var result = []; 
        if (typeof uri === 'string')
        {
            return uri.split('#')[1];
        }
        else if (Array.isArray(uri))
        {
            for(let element of uri)
            {
                result.push(element.split('#')[1]);
            }
            return result; 
        }
        else
        {
            return "";
        }
        
    }

}